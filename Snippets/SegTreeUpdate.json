{
	"Range update with timestamp and point queries": {
	"prefix": "Segment_tree_update",
	"body": [
		"template<class T>",
		"class SegmentTree{",
		"public:",
		"    int n;",
		"    vector<pair<T, int>> a;",
		"",
		"    SegmentTree() : n(0){}",
		"    SegmentTree(int sz) : a(4 * n, {0, 0}), n(sz){}",
		"    SegmentTree(const vector<T> &v){",
		"        this->n = v.size();",
		"        a.resize(4 * n, {0, 0});",
		"        build(1, 0, n - 1, v);",
		"    }",
		"",
		"    void build(int p, int l, int r, const vector<T> &v){",
		"        if(l == r){",
		"            a[p] = {v[l], 0};",
		"        }",
		"        else{",
		"            int m = (l + r) / 2;",
		"            build(2 * p, l, m, v);",
		"            build(2 * p + 1, m + 1, r, v);",
		"            a[p] = {0, 0};",
		"        }",
		"        return;",
		"    }",
		"",
		"    void findAt(int p, int l, int r, int idx, pair<T, int> &cur){",
		"        if(l == r) {",
		"            if(a[p].second >= cur.second){",
		"                cur = a[p];",
		"            }",
		"        }",
		"        else{",
		"            int m = (l + r) / 2;",
		"            if(idx <= m){",
		"                if(a[2 * p].second >= cur.second){",
		"                    cur = a[2 * p];",
		"                }",
		"                findAt(2 * p, l, m, idx, cur);",
		"            }",
		"            else{",
		"                if(a[2 * p + 1].second >= cur.second){",
		"                    cur = a[2 * p + 1];",
		"                }",
		"                findAt(2 * p + 1, m + 1, r, idx, cur);",
		"            }",
		"",
		"        }",
		"        return;",
		"    }",
		"",
		"    T findAt(int idx){",
		"        pair<T, int> cur = a[1];",
		"        findAt(1, 0, n - 1, idx, cur);",
		"        return cur.first;",
		"    }",
		"",
		"    void update(int p, int l, int r, int x, int y, int curTm, T val){",
		"        if(r < x || l > y){",
		"            return;",
		"        }",
		"        else if(x <= l && y >= r){",
		"            a[p] = make_pair(val, curTm);",
		"        }",
		"        else{",
		"            int m = (l + r) / 2;",
		"            update(2 * p, l, m, x, y, curTm, val);",
		"            update(2 * p + 1, m + 1, r, x, y, curTm, val);",
		"        }",
		"    }",
		"",
		"    void update(int l, int r, T val, int curTm){",
		"        update(1, 0, n - 1, l, r, curTm, val);",
		"        return;",
		"    }",
		"};"
	],
	"description": "Range update and point queries"
	}
}