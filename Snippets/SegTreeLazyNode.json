{
	"Lazy Segtree with Node": {
  "prefix": "Segment_tree_lazyNode",
  "body": [
    "template<class T, class comp = std::less<T>>",
    "class SegmentTree{",
    "private:",
    "    struct Node{",
    "        T val;",
    "        int cnt;",
    "        T lazy;",
    "    };",
    "",
    "    int n;",
    "    vector<Node> tree;",
    "    ",
    "    T build(int p, int l, int r, const vector<T> &v){",
    "        if(l == r){",
    "            tree[p].val = v[l];",
    "            tree[p].cnt = 1;",
    "            tree[p].lazy = 0;",
    "        }",
    "        else{",
    "            int m = (l + r) / 2;",
    "            T leftVal = build(2 * p, l, m, v);",
    "            T rightVal = build(2 * p + 1, m + 1, r, v);",
    "            tree[p].val = min(leftVal, rightVal, comp());",
    "            tree[p].cnt = 0;",
    "            if(tree[p].val == leftVal){",
    "                tree[p].cnt += tree[2 * p].cnt;",
    "            }",
    "            if(tree[p].val == rightVal){",
    "                tree[p].cnt += tree[2 * p + 1].cnt;",
    "            }",
    "            tree[p].lazy = 0;",
    "        }",
    "        return tree[p].val;",
    "    }",
    "",
    "    T find_val_at(int p, int l, int r, int pos){",
    "        if(l == r) {",
    "            return tree[p].val + tree[p].lazy;",
    "        }",
    "        else{",
    "            int m = (l + r) / 2;",
    "            if(pos <= m){",
    "                return tree[p].lazy + find_val_at(2 * p, l, m, pos);",
    "            }",
    "            else{",
    "                return tree[p].lazy + find_val_at(2 * p + 1, m + 1, r, pos);",
    "            }",
    "        }",
    "    }",
    "",
    "    pair<T, int> find(int p, int l, int r, int x, int y){",
    "        pair<T, int> res;",
    "        if constexpr (std::is_same_v<comp, std::less<T>>){",
    "            res = pair<T, int>(numeric_limits<T>::max(), 0);",
    "        }",
    "        else{",
    "            res = pair<T, int>(numeric_limits<T>::min(), 0);",
    "        }",
    "",
    "        if(y < l || x > r);",
    "        else if(l >= x && y >= r){",
    "            res = {tree[p].lazy + tree[p].val, tree[p].cnt};",
    "        }",
    "        else if(l == r);",
    "        else{",
    "            int m = (l + r) / 2;",
    "            pair<T, int> leftNode = find(2 * p, l, m, x, y);",
    "            pair<T, int> rightNode = find(2 * p + 1, m + 1, r, x, y);",
    "            res = {min(leftNode.first, rightNode.first, comp()), 0};",
    "            if(res.first == leftNode.first){",
    "                res.second += leftNode.second;",
    "            }",
    "            if(res.first == rightNode.first){",
    "                res.second += rightNode.second;",
    "            }",
    "            res.first += tree[p].lazy;",
    "        }",
    "        return res;",
    "    }",
    "",
    "    T add(int p, int l, int r, int x, int y, T val){",
    "        if(y < l || x > r){",
    "            return tree[p].lazy + tree[p].val;",
    "        }",
    "        else if(l >= x && y >= r){",
    "            tree[p].lazy += val;",
    "            return tree[p].lazy + tree[p].val;",
    "        }",
    "        else if(l == r) return tree[p].lazy + tree[p].val;",
    "        else{",
    "            int m = (l + r) / 2;",
    "            T leftVal = add(2 * p, l, m, x, y, val);",
    "            T rightVal = add(2 * p + 1, m + 1, r, x, y, val);",
    "            tree[p].val = min(leftVal, rightVal, comp());",
    "            tree[p].cnt = 0;",
    "            if(tree[p].val == leftVal){",
    "                tree[p].cnt += tree[2 * p].cnt;",
    "            }",
    "            if(tree[p].val == rightVal){",
    "                tree[p].cnt += tree[2 * p + 1].cnt;",
    "            }",
    "        }",
    "        return tree[p].lazy + tree[p].val;",
    "    }",
    "",
    "public:",
    "",
    "    SegmentTree() : n(0){}",
    "    SegmentTree(int sz){",
    "        this->n = sz;",
    "        tree.resize(4 * n);",
    "        vector<T> v(n, 0);",
    "        build(1, 0, n - 1, v);",
    "    }",
    "    SegmentTree(const vector<T> &v){",
    "        this->n = v.size();",
    "        tree.resize(4 * n);",
    "        build(1, 0, n - 1, v);",
    "    }",
    "",
    "    pair<T, int> find(int l, int r){",
    "        return find(1, 0, n - 1, l, r);",
    "    }",
    "    ",
    "    T find_val(int l, int r){",
    "        return find(1, 0, n - 1, l, r).first;",
    "    }",
    "",
    "    int find_Cnt(int l, int r){",
    "        return find(1, 0, n - 1, l, r).second;",
    "    }",
    "",
    "    T find_val_at(int pos){",
    "        return find_val_at(1, 0, n - 1, pos);",
    "    }",
    "",
    "    T add(int l, int r, T val){",
    "        return add(1, 0, n - 1, l, r, val);",
    "    }",
    "};"
  ],
  "description": "Lazy Segtree with Node"
}
}